{
  "page-1": {
    "title": "Introduction to Flask",
    "section": "Overview",
    "markdown": "# Introduction to Flask\n## Overview\nFlask is a lightweight WSGI web application framework designed to make getting started quick and easy, with the ability to scale up to complex applications. It is located in the [src/flask](src/flask) directory and can be imported using `from flask import Flask`.\n\n## Key Components / Concepts\nThe key components of Flask include the Flask class, which implements a WSGI application and acts as the central object, and the App class, which is a subclass of the Flask class. These classes are defined in [src/flask/app.py](src/flask/app.py) and provide the core functionality for building web applications.\n\n## How it Works\nFlask works by creating an instance of the Flask class, which is passed the name of the module or package of the application. The instance acts as a central registry for view functions, URL rules, template configuration, and more. This process is outlined in [docs/quickstart.rst](docs/quickstart.rst).\n\n## Example(s)\nA simple example of a Flask application is:\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n```\nThis example demonstrates how to create a basic Flask application and define a route for the root URL.\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant Flask as \"Flask Class\"\n    participant App as \"App Class\"\n    participant User as \"User\"\n    User->>Flask: Create instance\n    Flask->>App: Inherit from App\n    App->>User: Return response\n```\nThis diagram shows the relationship between the Flask class, the App class, and the user, and is based on the architecture described in [docs/tutorial/index.rst](docs/tutorial/index.rst).\n\n## References\n* `[README.md](README.md)`\n* `[src/flask/app.py](src/flask/app.py)`\n* `[docs/quickstart.rst](docs/quickstart.rst)`\n* `[docs/tutorial/index.rst](docs/tutorial/index.rst)`"
  },
  "page-7": {
    "title": "Introduction to Flask Testing",
    "section": "Overview",
    "markdown": "# Introduction to Flask Testing\n## Overview\nFlask provides utilities for testing an application, including a test client that simulates requests to the application and returns the response data. Testing is an essential part of the development process, ensuring that the code works as expected and catching any bugs or errors early on. The test client is typically used in conjunction with the `pytest` framework, which can be found in the [tests/test_basic.py](tests/test_basic.py) and [tests/test_testing.py](tests/test_testing.py) files.\n\n## Key Components / Concepts\nThe key components of Flask testing include:\n- Test client: a simulated client that sends requests to the application\n- Test functions: functions that start with `test_` and contain the test code\n- Fixtures: reusable pieces of code that can be used across multiple tests\n\n## How it Works\nTo test a Flask application, you would typically use the `pytest` framework to set up and run your tests. You can write test functions that use the test client to simulate requests to the application and then assert that the response is as expected. For more information on testing in Flask, see the [docs/testing.rst](docs/testing.rst) file.\n\n## Example(s)\nFor example, you might write a test function that tests a route that returns a JSON response:\n```python\ndef test_hello():\n    response = client.get('/hello')\n    assert response.json == {'message': 'Hello, World!'}\n```\n## Diagram(s)\n```mermaid\nflowchart\n    participant Client as \"Test Client\"\n    participant App as \"Flask Application\"\n    Client->>App: Send request\n    App->>Client: Return response\n    Client->>Client: Assert response\n```\nThis diagram shows the basic flow of a test, with the test client sending a request to the application and then asserting that the response is as expected.\n\n## References\n- `[tests/test_basic.py](tests/test_basic.py)`\n- `[tests/test_testing.py](tests/test_testing.py)`\n- `[docs/testing.rst](docs/testing.rst)`"
  },
  "page-10": {
    "title": "Introduction to Examples",
    "section": "Overview",
    "markdown": "# Introduction to Examples\n## Overview\nThe Flask Wiki repository, located at `flask_wiki/`, provides various examples to demonstrate the usage and capabilities of the Flask framework. These examples range from basic applications to more complex ones, showcasing different features and use cases, such as those found in `examples/tutorial/` and `examples/advanced/`.\n\n## Key Components / Concepts\nThe examples in the repository cover key components and concepts of Flask, including routing, templating, and database integration, as seen in `examples/database/`. They also demonstrate how to structure and organize a Flask application, making it easier for developers to understand and implement their own projects, using techniques from `examples/structure/`.\n\n## How it Works\nEach example in the repository is a self-contained application that can be run and tested independently, following the instructions in `examples/tutorial/README.rst`. They are designed to be easy to understand and modify, allowing developers to experiment and learn from them, with tests available in `tests/test_basic.py` and `tests/test_blueprints.py`.\n\n## Example(s)\nOne of the examples provided is the Flaskr tutorial, which is a basic blog application built using Flask, located at `examples/tutorial/`. This example demonstrates how to create a simple web application using Flask, including routing, templating, and database integration.\n\n## Diagram(s)\n```mermaid\nflowchart\n    A[User] -->|requests|> B[Flask App]\n    B -->|routes|> C[View Function]\n    C -->|renders|> D[Template]\n    D -->|returns|> B\n    B -->|returns|> A\n```\nThis flowchart shows the basic flow of a Flask application, from the user requesting a page to the application returning the rendered template.\n\n## References\n* `examples/tutorial/README.rst`\n* `tests/test_basic.py`\n* `docs/changes.rst`\n* `examples/advanced/README.md`"
  },
  "page-17": {
    "title": "Introduction to Flask",
    "section": "Overview",
    "markdown": "# Introduction to Flask\n## Overview\nFlask is a lightweight WSGI web application framework designed to make getting started quick and easy, with the ability to scale up to complex applications. It is located in the `src/flask` directory of the repository.\n\n## Key Components / Concepts\nThe key components of Flask include the Flask class, which is a subclass of the `flask.Flask` class, and the App class, which is a subclass of the `Scaffold` class. The Flask class takes no explicit inputs but is configured through the `config_class` attribute, as seen in `src/flask/app.py`.\n\n## How it Works\nFlask works by creating an instance of the Flask class, which is passed the name of the module or package of the application. The name of the package is used to resolve resources from inside the package or the folder the module is contained in, as described in `docs/quickstart.rst`.\n\n## Example(s)\nA simple example of a Flask application is:\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n```\nThis code creates a Flask application that responds to requests to the root URL (\"/\") with the message \"Hello, World!\", as outlined in `README.md`.\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant Flask as \"Flask Application\"\n    participant User as \"User\"\n    participant Server as \"Server\"\n\n    User->>Flask: Request\n    Flask->>Server: Process Request\n    Server->>Flask: Response\n    Flask->>User: Response\n```\nThis diagram shows the basic flow of a Flask application, where a user makes a request to the application, which is then processed by the server and returned to the user.\n\n## References\n* `[README.md](README.md)`\n* `[docs/index.rst](docs/index.rst)`\n* `[src/flask/app.py](src/flask/app.py)`"
  },
  "page-22": {
    "title": "Introduction to Flask",
    "section": "Overview",
    "markdown": "# Introduction to Flask\n## Overview\nFlask is a lightweight WSGI web application framework designed to make getting started quick and easy, with the ability to scale up to complex applications. It is located in the [src/flask/app.py](src/flask/app.py) file and can be run using the development server as described in [README.md](README.md).\n\n## Key Components / Concepts\nThe key components of Flask include the Flask class, which is the central object of the application, and the various functions and decorators that are used to define routes, handle requests, and render templates. These components are utilized in the example application found in [docs/quickstart.rst](docs/quickstart.rst).\n\n## How it Works\nFlask works by creating an instance of the Flask class, which is then used to define routes and handle requests. The application can be run using the `run` method, which starts the development server. A detailed explanation of this process can be found in [docs/tutorial/index.rst](docs/tutorial/index.rst).\n\n## Example(s)\nA simple example of a Flask application is:\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello():\n    return \"Hello, World!\"\n```\nThis application defines a single route, `/`, which returns the string \"Hello, World!\".\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant Flask as \"Flask Application\"\n    participant Client as \"Client\"\n    participant Server as \"Server\"\n\n    note \"Client requests URL\"\n    Client->>Server: Request URL\n    Server->>Flask: Receive request\n    Flask->>Server: Process request\n    Server->>Client: Return response\n```\nThis diagram shows the basic flow of a Flask application, with the client requesting a URL, the server receiving the request, the Flask application processing the request, and the server returning the response to the client.\n\n## References\n* `[README.md](README.md)`\n* `[src/flask/app.py](src/flask/app.py)`\n* `[docs/quickstart.rst](docs/quickstart.rst)`\n* `[docs/tutorial/index.rst](docs/tutorial/index.rst)`"
  },
  "page-2": {
    "title": "Project Structure",
    "section": "Core Features",
    "markdown": "# Project Structure\n## Overview\nThe project structure is defined in the `pyproject.toml` file, which is the configuration file for the project. This file contains information about the project's dependencies, build settings, and other metadata.\n\n## Key Components / Concepts\nThe key components of the project structure include the `src` directory, which contains the source code for the project, and the `tests` directory, which contains the unit tests for the project. The `src/flask` directory contains the Flask application code, and the `tests/test_config.py` file contains tests for the configuration loading.\n\n## How it Works\nThe project structure is loaded from the `pyproject.toml` file when the project is built or run. The `pyproject.toml` file specifies the dependencies required by the project, and the build settings for the project.\n\n## Example(s)\nFor example, the `pyproject.toml` file might contain the following configuration:\n```toml\n[build-system]\nrequires = [\"poetry>=0.12\"]\nbuild-backend = \"poetry.masonry.api\"\n\n[tool.poetry]\nname = \"flask-wiki\"\nversion = \"1.0.0\"\ndescription = \"A wiki built with Flask\"\n```\n## Diagram(s)\n```mermaid\nflowchart\n    A[pyproject.toml] --> B[Load Configuration]\n    B --> C[Build Project]\n    C --> D[Run Project]\n```\nThe diagram shows the flow of the project structure loading and building process.\n\n## References\n* `pyproject.toml`\n* `src/flask/app.py`\n* `tests/test_config.py`"
  },
  "page-4": {
    "title": "Testing Framework",
    "section": "Core Features",
    "markdown": "# Testing Framework\n## Overview\nThe testing framework in Flask is designed to make it easy to write and run tests for your application. It provides a number of tools and utilities to help you test your code, including the `test_client` and `test_request_context` functions, which can be found in `src/flask/testing.py`.\n\n## Key Components / Concepts\nThe `test_client` function is used to create a test client for your application, as defined in `src/flask/app.py`. This client can be used to simulate requests to your application and test its responses. The `test_request_context` function is used to create a request context for your application, which can be used to test functions that rely on the request context.\n\n## How it Works\nTo use the testing framework, you first need to create a test client or request context. You can then use this client or context to test your application's functions and routes. The `test_client` function returns a test client object, which has methods for simulating different types of requests, such as `get` and `post`.\n\n## Example(s)\nHere is an example of how to use the `test_client` function to test a route:\n```python\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    return \"Hello World!\"\n\nclient = app.test_client()\nresponse = client.get(\"/\")\nassert response.data == b\"Hello World!\"\n```\nAnd here is an example of how to use the `test_request_context` function to test a function that relies on the request context:\n```python\napp = Flask(__name__)\n\ndef my_function():\n    return flask.request.path\n\nwith app.test_request_context(\"/\"):\n    assert my_function() == \"/\"\n```\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant App as \"Flask App\"\n    participant TestClient as \"Test Client\"\n    participant RequestContext as \"Request Context\"\n\n    App->>TestClient: Create test client\n    TestClient->>App: Simulate request\n    App->>RequestContext: Create request context\n    RequestContext->>App: Provide request data\n    App->>TestClient: Return response\n    TestClient->>App: Assert response\n```\nThis diagram shows the flow of a test using the `test_client` and `test_request_context` functions.\n\n## References\n* `src/flask/app.py`\n* `src/flask/testing.py`\n* `tests/test_testing.py`"
  },
  "page-14": {
    "title": "Database Management",
    "section": "Core Features",
    "markdown": "# Database Management\n## Overview\nThe Flask Wiki repository provides a robust database management system, allowing for efficient data storage and retrieval. This system is built around the SQLite database engine and utilizes the Flask-SQLAlchemy extension for ORM (Object-Relational Mapping) capabilities.\n\n## Key Components / Concepts\nThe database management system consists of several key components, including:\n* `get_db()`: a function that connects to the application's configured database\n* `init_db()`: a function that clears existing data and creates new tables\n* `close_db()`: a function that closes the database connection\n* `init_db_command()`: a function that initializes the database\n\n## How it Works\nThe database management system works as follows:\n1. The `get_db()` function is called to connect to the database.\n2. The `init_db()` function is called to clear existing data and create new tables.\n3. The `close_db()` function is called to close the database connection.\n\n## Example(s)\nAn example of how to use the database management system can be seen in the `examples/tutorial/flaskr/blog.py` file, where the `index()` function retrieves all posts from the database and renders an HTML template.\n\n## Diagram(s)\n```mermaid\nflowchart\n    A[get_db()] --> B[init_db()]\n    B --> C[close_db()]\n    C --> D[Database Connection Closed]\n    A --> E[Database Connection Established]\n    E --> F[Retrieve Data]\n    F --> G[Render HTML Template]\n```\nThis flowchart illustrates the database management system's workflow, from connecting to the database to rendering an HTML template.\n\n## References\n* `examples/tutorial/flaskr/db.py`\n* `examples/tutorial/flaskr/schema.sql`\n* `flask/wiki/core/database.py` \n* `examples/tutorial/flaskr/blog.py`"
  },
  "page-15": {
    "title": "Authentication and Authorization",
    "section": "Core Features",
    "markdown": "# Authentication and Authorization\n## Overview\nThe Flask Wiki repository, located at `src/flask/wiki`, provides authentication and authorization features to manage user access and permissions. These features are essential for ensuring the security and integrity of the wiki, as seen in the implementation details within `examples/tutorial/flaskr/auth.py`.\n\n## Key Components / Concepts\nThe authentication and authorization system consists of several key components, including user registration, login, and logout functionality, all of which are handled by the `auth` module in `examples/tutorial/flaskr/auth.py`. The system also includes permission checks to ensure that users can only access and modify content that they are authorized to, as defined in `examples/tutorial/tests/test_auth.py`.\n\n## How it Works\nThe authentication process involves a user registering for an account, logging in with their credentials, and being assigned a session ID. This process is facilitated by the `login` and `register` functions within `src/flask/sansio/scaffold.py`. The authorization process involves checking the user's permissions and access levels to determine what actions they can perform on the wiki, which is tested in `examples/tutorial/tests/conftest.py`.\n\n## Example(s)\nFor example, a user can register for an account by providing a username and password. They can then log in to the wiki using their credentials and access content that they are authorized to view or modify. This is demonstrated in the test cases found in `examples/tutorial/tests/test_auth.py`.\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant User as \"User\"\n    participant Wiki as \"Wiki\"\n    participant Database as \"Database\"\n\n    User->>Wiki: Register\n    Wiki->>Database: Create user account\n    Database->>Wiki: Return user ID\n    Wiki->>User: Return registration success\n\n    User->>Wiki: Login\n    Wiki->>Database: Verify user credentials\n    Database->>Wiki: Return user ID and permissions\n    Wiki->>User: Return login success and session ID\n\n    User->>Wiki: Access content\n    Wiki->>Database: Check user permissions\n    Database->>Wiki: Return access level\n    Wiki->>User: Return content or access denied\n```\nCaption: Authentication and Authorization Flowchart\n\n## References\n* `examples/tutorial/flaskr/auth.py`\n* `examples/tutorial/tests/test_auth.py`\n* `src/flask/sansio/scaffold.py`"
  },
  "page-18": {
    "title": "Request and Response Objects",
    "section": "Core Features",
    "markdown": "# Request and Response Objects\n## Overview\nFlask provides a request object to handle HTTP requests and a response object to handle HTTP responses. These objects are crucial for building web applications, as they allow developers to interact with the HTTP protocol and handle requests and responses in a flexible and efficient way.\n\n## Key Components / Concepts\nThe request object is an instance of the `Request` class, which is a subclass of `RequestBase`. It provides attributes and methods for accessing request data, such as the request method, URL, headers, and body. The response object is an instance of the `Response` class, which is a subclass of `ResponseBase`. It provides attributes and methods for setting response data, such as the status code, headers, and body.\n\n## How it Works\nWhen a request is made to a Flask application, the `Request` object is created and populated with data from the request. The `Request` object is then passed to the view function, which can access its attributes and methods to handle the request. The view function can return a response object, which is then sent back to the client.\n\n## Example(s)\nHere is an example of how to use the `Request` and `Response` objects in a Flask view function:\n```python\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/example', methods=['GET', 'POST'])\ndef example():\n    if request.method == 'GET':\n        return jsonify({'message': 'Hello, World!'})\n    elif request.method == 'POST':\n        data = request.get_json()\n        return jsonify({'message': 'Received data: {}'.format(data)})\n```\n## Diagram(s)\n```mermaid\nflowchart\n    participant Client as \"Client\"\n    participant Flask as \"Flask\"\n    participant View as \"View Function\"\n    participant Request as \"Request Object\"\n    participant Response as \"Response Object\"\n\n    Client->>Flask: Send Request\n    Flask->>Request: Create Request Object\n    Request->>View: Pass Request Object\n    View->>Response: Create Response Object\n    Response->>Flask: Return Response Object\n    Flask->>Client: Send Response\n```\nThis diagram shows the flow of a request and response in a Flask application.\n\n## References\n* `src/flask/wrappers.py`: This file contains the implementation of the `Request` and `Response` classes.\n* `src/flask/ctx.py`: This file contains the implementation of the `request` context manager.\n* `src/flask/helpers.py`: This file contains the implementation of the `make_response` function.\n* `docs/reqcontext.rst`: This file contains documentation on the request context in Flask."
  },
  "page-19": {
    "title": "Routing and URL Building",
    "section": "Core Features",
    "markdown": "# Routing and URL Building\n## Overview\nFlask provides a flexible routing system and tools for building URLs, allowing developers to create complex and dynamic web applications with ease, as seen in the `src/flask/app.py` file.\n\n## Key Components / Concepts\nThe key components of Flask's routing system include the `@app.route()` decorator, which is used to associate a function with a specific URL rule, and the `url_for()` function, which is used to generate URLs for a given endpoint, both of which are utilized in `src/flask/helpers.py`.\n\n## How it Works\nWhen a request is made to a Flask application, the routing system matches the URL to a specific endpoint, as defined in `src/flask/sansio/scaffold.py`. The endpoint is then used to determine which function to call to handle the request. The `url_for()` function can be used to generate URLs for a given endpoint, which can be useful for creating links and redirects.\n\n## Example(s)\nFor example, the following code defines a route for the root URL of an application:\n```python\n@app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n```\nThe `url_for()` function can be used to generate a URL for this endpoint:\n```python\nurl = url_for(\"index\")\n```\nThis is further demonstrated in `tests/test_blueprints.py`, where test cases are defined to verify the correctness of the routing system.\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant Client as \"Client\"\n    participant Router as \"Router\"\n    participant Endpoint as \"Endpoint\"\n    participant Function as \"Function\"\n\n    Client->>Router: Request\n    Router->>Endpoint: Match URL\n    Endpoint->>Function: Call function\n    Function->>Client: Response\n```\nThis diagram shows the flow of a request through the routing system, illustrating how the `@app.route()` decorator and `url_for()` function work together to handle requests and generate URLs.\n\n## References\n* `src/flask/app.py`\n* `src/flask/helpers.py`\n* `src/flask/sansio/scaffold.py`"
  },
  "page-23": {
    "title": "Request and Response Objects",
    "section": "Core Features",
    "markdown": "# Request and Response Objects\n## Overview\nFlask provides a request object to handle HTTP requests and a response object to handle HTTP responses. These objects are crucial for building web applications, as they allow developers to interact with the HTTP protocol and handle requests and responses in a flexible and efficient way.\n\n## Key Components / Concepts\nThe request object is an instance of the `Request` class, which is a subclass of `RequestBase`. It provides attributes and methods for accessing request data, such as the request method, URL, headers, and body. The response object is an instance of the `Response` class, which is a subclass of `ResponseBase`. It provides attributes and methods for setting response data, such as the status code, headers, and body.\n\n## How it Works\nWhen a request is made to a Flask application, the `Request` object is created and populated with data from the request. The `Request` object is then passed to the view function, which can access its attributes and methods to handle the request. The view function can return a response object, which is then sent back to the client.\n\n## Example(s)\nHere is an example of how to use the `Request` and `Response` objects in a Flask view function:\n```python\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/example', methods=['GET', 'POST'])\ndef example():\n    if request.method == 'GET':\n        return jsonify({'message': 'Hello, World!'})\n    elif request.method == 'POST':\n        data = request.get_json()\n        return jsonify({'message': 'Received data: {}'.format(data)})\n```\n## Diagram(s)\n```mermaid\nflowchart\n    participant Client as \"Client\"\n    participant Flask as \"Flask\"\n    participant View as \"View Function\"\n    participant Request as \"Request Object\"\n    participant Response as \"Response Object\"\n\n    Client->>Flask: Send Request\n    Flask->>Request: Create Request Object\n    Request->>View: Pass Request Object\n    View->>Response: Create Response Object\n    Response->>Flask: Return Response Object\n    Flask->>Client: Send Response\n```\nThis diagram shows the flow of a request and response in a Flask application.\n\n## References\n* `src/flask/wrappers.py`: This file contains the implementation of the `Request` and `Response` classes.\n* `src/flask/helpers.py`: This file contains helper functions for working with requests and responses, such as `make_response`.\n* `src/flask/globals.py`: This file contains global variables and functions for accessing the request and response objects.\n* `tests/test_basic.py`: This file contains tests for the request and response objects."
  },
  "page-24": {
    "title": "Template Engine",
    "section": "Core Features",
    "markdown": "# Template Engine\n## Overview\nFlask uses the Jinja2 template engine to render templates. The Jinja environment is created when the `jinja_env` property is accessed, and it is used to load templates from the `templates` folder, as specified in `src/flask/app.py`.\n\n## Key Components / Concepts\nThe key components of the template engine are:\n- `jinja_env`: The Jinja environment used to load templates.\n- `create_jinja_environment`: A method that creates the Jinja environment based on the `jinja_options` and various Jinja-related methods of the app, as defined in `src/flask/templating.py`.\n- `render_template`: A function that renders a template by name with the given context.\n- `render_template_string`: A function that renders a template from the given source string with the given context.\n\n## How it Works\nThe template engine works by creating a Jinja environment when the `jinja_env` property is accessed. The `create_jinja_environment` method is used to create the environment, and it adds Flask-related globals and filters to the environment. The `render_template` and `render_template_string` functions are used to render templates with the given context, as demonstrated in `tests/test_templating.py`.\n\n## Example(s)\nAn example of using the template engine is:\n```python\nfrom flask import render_template\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n```\nThis example renders the `index.html` template when the `/` route is accessed.\n\n## Diagram(s)\n```mermaid\nflowchart\n    A[Create Jinja Environment] --> B[Load Template]\n    B --> C[Render Template]\n    C --> D[Return Rendered Template]\n```\nThis diagram shows the flow of the template engine, from creating the Jinja environment to rendering the template and returning the rendered template.\n\n## References\n- `src/flask/app.py`\n- `src/flask/templating.py`\n- `tests/test_templating.py`\n- `src/flask/sansio/app.py`"
  },
  "page-3": {
    "title": "Readthedocs Configuration",
    "section": "Deployment/Infrastructure",
    "markdown": "# Readthedocs Configuration\n## Overview\nThe Readthedocs configuration is defined in the `.readthedocs.yaml` file, which serves as a configuration file for Read the Docs, a documentation hosting platform. This file defines the build process for documentation projects, including the operating system, Python version, and commands to install and run the necessary tools.\n\n## Key Components / Concepts\nThe key components of the Readthedocs configuration include the `version`, `build`, and `commands` sections. The `version` section specifies the version of the configuration file, while the `build` section defines the operating system and Python version used for building the documentation. The `commands` section lists the commands to be executed during the build process, including the installation of dependencies and the generation of HTML documentation files.\n\n## How it Works\nThe Readthedocs configuration file is used to automate the build process for documentation projects. When a build is triggered, Read the Docs reads the configuration file and executes the commands specified in the `commands` section. This includes installing dependencies, generating HTML documentation files, and uploading the built documentation to the Read the Docs platform.\n\n## Example(s)\nAn example of a Readthedocs configuration file is provided in the `.readthedocs.yaml` file, which includes the following configuration:\n```yml\nversion: 2\nbuild:\n  os: ubuntu-24.04\n  tools:\n    python: '3.13'\n  commands:\n    - asdf plugin add uv\n    - asdf install uv latest\n    - asdf global uv latest\n    - uv run --group docs sphinx-build -W -b dirhtml docs $READTHEDOCS_OUTPUT/html\n```\n## Diagram(s)\n```mermaid\ngraph LR\n    A[Readthedocs Configuration] -->|defines|> B[Build Process]\n    B -->|includes|> C[Operating System]\n    B -->|includes|> D[Python Version]\n    B -->|includes|> E[Commands]\n    E -->|executes|> F[Install Dependencies]\n    E -->|executes|> G[Generate HTML Documentation]\n    G -->|uploads|> H[Read the Docs Platform]\n```\nCaption: Readthedocs Configuration Diagram\n\n## References\n* `.readthedocs.yaml`\n* `tests/test_config.py`\n* `src/flask/config.py`"
  },
  "page-9": {
    "title": "Running Flask Applications",
    "section": "Deployment/Infrastructure",
    "markdown": "# Running Flask Applications\n## Overview\nRunning a Flask application can be done in various ways, including using the built-in development server or deploying to a production environment. The development server is suitable for testing and debugging purposes, while a production environment is necessary for deploying the application to a wider audience.\n\n## Key Components / Concepts\nThe key components involved in running a Flask application include the Flask application instance, the WSGI server, and the HTTP server. The Flask application instance is the core of the application, and it is created using the `Flask` class from the `flask` module. The WSGI server is responsible for managing the interaction between the Flask application and the HTTP server.\n\n## How it Works\nTo run a Flask application, you can use the `flask run` command, which starts the development server. In debug mode, this server provides an interactive debugger and will reload when code is changed. The `flask run` command is located in the `src/flask/cli.py` file. The development server uses the WSGI interface to interact with the Flask application, and it uses the HTTP interface to interact with the client.\n\n## Example(s)\nHere's an example of how to create a simple Flask application:\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n```\nYou can then run the application using the `flask run` command. This command is documented in the `docs/deploying/index.rst` file.\n\n## Diagram(s)\n```mermaid\ngraph LR\n    A[Flask Application] -->|WSGI Interface|> B[WSGI Server]\n    B -->|HTTP Interface|> C[HTTP Server]\n    C -->|HTTP Request|> D[Client]\n    D -->|HTTP Response|> C\n```\nThis diagram shows the high-level architecture of a Flask application, including the WSGI server and HTTP server. The diagram illustrates how the Flask application interacts with the WSGI server and the HTTP server.\n\n## References\n* `src/flask/app.py`\n* `docs/deploying/index.rst`\n* `docs/server.rst`"
  },
  "page-16": {
    "title": "Running the Application",
    "section": "Deployment/Infrastructure",
    "markdown": "# Running the Application\n## Overview\nTo run the Flask application, you can use the `run` function from the `src/flask/app.py` file. This function runs the application on a local development server.\n\n## Key Components / Concepts\nThe `run` function takes several parameters, including `host`, `port`, `debug`, and `load_dotenv`. The `debug` flag enables debug mode, which provides features like automatic reloading and a debugger.\n\n## How it Works\nWhen you call the `run` function, it starts the development server and makes the application available at the specified host and port. If the `debug` flag is set, the server will automatically reload when code changes are detected.\n\n## Example(s)\nTo run the application, you can use the following code:\n```python\nfrom src.flask.app import run\n\nrun(host='localhost', port=5000, debug=True)\n```\n## Diagram(s)\n```mermaid\ngraph LR\n    A[Run Function] -->|host|> B[Development Server]\n    A -->|port|> B\n    A -->|debug|> C[Debug Mode]\n    B --> D[Application]\n    C --> D\n```\nRunning the Application Diagram\n\n## References\n* `src/flask/app.py`\n* `docs/deploying/index.rst`\n* `docs/cli.rst`"
  },
  "page-20": {
    "title": "Deploying Flask Applications",
    "section": "Deployment/Infrastructure",
    "markdown": "# Deploying Flask Applications\n## Overview\nFlask applications can be deployed using various WSGI servers and deployment tools. The application object implements a WSGI application and acts as the central object, which is passed the name of the module or package of the application.\n\n## Key Components / Concepts\nThe key components involved in deploying a Flask application include the WSGI server, the HTTP server, and the application object itself. The WSGI server is used to run the application, converting incoming HTTP requests to the standard WSGI environ, and converting outgoing WSGI responses to HTTP responses.\n\n## How it Works\nTo deploy a Flask application, you first need to create and configure an instance of the Flask application. This involves setting up the application's root path, enabling testing mode, and defining a secret key. You can then use a WSGI server to run the application, and an HTTP server to handle incoming requests.\n\n## Example(s)\nFor example, you can use the `create_app` function in `examples/tutorial/flaskr/__init__.py` to create and configure a Flask application instance.\n\n## Diagram(s)\n```mermaid\ngraph LR\n    A[Flask Application] -->|WSGI Server|> B[HTTP Server]\n    B -->|HTTP Request|> A\n    A -->|WSGI Response|> B\n    B -->|HTTP Response|> C[Client]\n```\nThis diagram shows the basic flow of a Flask application deployment, with the WSGI server running the application and the HTTP server handling incoming requests.\n\n## References\n* `src/flask/app.py`\n* `examples/tutorial/flaskr/__init__.py`\n* `docs/deploying/index.rst`\n* `docs/tutorial/deploy.rst`"
  },
  "page-5": {
    "title": "Request and Response Objects",
    "section": "Backend Systems",
    "markdown": "# Request and Response Objects\n## Overview\nThe request and response objects are fundamental components in Flask, a micro web framework written in Python, located in the `src/flask` directory. These objects are used to handle HTTP requests and responses, providing a way to interact with the client and server.\n\n## Key Components / Concepts\nThe `Request` object, defined in `src/flask/wrappers.py`, is used to represent an HTTP request, while the `Response` object represents an HTTP response. Both objects have various attributes and methods that can be used to access and manipulate the request and response data.\n\n## How it Works\nWhen a client sends an HTTP request to the server, Flask creates a `Request` object to represent the request. The `Request` object contains information such as the request method, URL, headers, and data, which can be accessed using methods like `request.get_json()` in `src/flask/helpers.py`. The application can then use this object to process the request and generate a response.\n\nThe `Response` object is used to represent the HTTP response sent back to the client. It contains information such as the response status code, headers, and data. The application can use the `Response` object to set the response status code, headers, and data.\n\n## Example(s)\nHere is an example of how to use the `Request` and `Response` objects in a Flask application:\n```python\nfrom flask import Flask, request, Response\n\napp = Flask(__name__)\n\n@app.route('/', methods=['GET', 'POST'])\ndef index():\n    if request.method == 'GET':\n        return Response('Hello, World!', status=200)\n    elif request.method == 'POST':\n        data = request.get_json()\n        return Response('Received data: {}'.format(data), status=200)\n```\n## Diagram(s)\n```mermaid\nsequenceDiagram\n    participant Client as \"Client\"\n    participant Server as \"Server\"\n    participant Flask as \"Flask\"\n    participant Request as \"Request\"\n    participant Response as \"Response\"\n\n    Client->>Server: Send HTTP request\n    Server->>Flask: Receive request\n    Flask->>Request: Create Request object\n    Request->>Flask: Process request\n    Flask->>Response: Create Response object\n    Response->>Flask: Set response status code and headers\n    Flask->>Server: Send response back to client\n    Server->>Client: Receive response\n```\nThis sequence diagram shows the flow of an HTTP request and response in a Flask application.\n\n## References\n* `src/flask/wrappers.py`\n* `tests/test_views.py`\n* `src/flask/helpers.py`\n* `tests/test_basic.py`"
  },
  "page-25": {
    "title": "Application Context",
    "section": "Backend Systems",
    "markdown": "# Application Context\n## Overview\nThe application context in Flask is a crucial component that handles requests and responses, providing an environment where the application can execute and making key objects such as the current application instance and the request object available. This context is rooted in the `src/flask/app.py` and `src/flask/ctx.py` files.\n\n## Key Components / Concepts\n- **AppContext**: This is the core class representing the application context, encapsulating the application and, optionally, request information, as defined in `src/flask/ctx.py`.\n- **Request Context**: A specific type of application context that includes request information, automatically pushed when handling requests.\n- **Test Request Context**: A method to create a request context for testing purposes, allowing the simulation of requests without actually dispatching them, utilized in `tests/test_appctx.py`.\n\n## How it Works\nWhen a request is made to a Flask application, an application context is automatically created, making the current application (`current_app`) and the global object (`g`) available. For testing or setup outside of request handling, the `app_context` method can be used to manually push a context, as demonstrated in `tests/test_appctx.py`.\n\n## Example(s)\nTo use the application context in a test, you might do something like:\n```python\nwith app.test_request_context('/'):\n    # Now you can access request, session, g, and current_app\n    print(request.path)\n```\nThis example illustrates how to simulate a request to the root path (`'/'`) of the application and access the request path.\n\n## Diagram(s)\n```mermaid\nsequenceDiagram\n    participant App as \"Flask App\"\n    participant Context as \"Application Context\"\n    participant Request as \"Incoming Request\"\n    \n    Note over App,Context: Application startup\n    App->>Context: Create app context\n    Context->>App: Make current_app, g available\n    \n    Note over Request,Context: Request received\n    Request->>Context: Push request context\n    Context->>Request: Make request, session available\n    \n    Note over App,Context: Request handling\n    App->>Context: Access current_app, request, session, g\n    Context->>App: Execute request handlers\n    \n    Note over Request,Context: Request complete\n    Request->>Context: Pop request context\n    Context->>Request: Clean up\n```\nCaption: Sequence of creating and using an application context in Flask.\n\n## References\n- `src/flask/app.py`\n- `src/flask/ctx.py`\n- `tests/test_appctx.py`"
  },
  "page-26": {
    "title": "Signal Handling",
    "section": "Backend Systems",
    "markdown": "# Signal Handling\n## Overview\nFlask provides a signal handling system to handle events, allowing developers to execute code in response to specific events, such as when a request is started or finished, as defined in [src/flask/app.py](src/flask/app.py).\n\n## Key Components / Concepts\nThe key components of Flask's signal handling system are:\n* Signals: These are events that are sent by Flask when certain actions occur, such as the `request_started` signal.\n* Handlers: These are functions that are executed in response to signals, as demonstrated in [tests/test_signals.py](tests/test_signals.py).\n\n## How it Works\nWhen a signal is sent, Flask checks if there are any handlers connected to that signal. If there are, Flask executes the handlers in the order they were connected, utilizing the signal handling mechanism outlined in [src/flask/signals.py](src/flask/signals.py).\n\n## Example(s)\nFor example, the `request_started` signal is sent when a request is started. A handler can be connected to this signal to execute code before the request is processed, as shown in the following code snippet:\n```python\nfrom flask import request\n\ndef handle_request_started(sender):\n    # Execute code before the request is processed\n    print(\"Request started\")\n\n# Connect the handler to the request_started signal\nrequest_started.connect(handle_request_started)\n```\n\n## Diagram(s)\n```mermaid\nsequenceDiagram\n    participant Flask as \"Flask\"\n    participant Handler as \"Handler\"\n    Note over Flask,Handler: Request started\n    Flask->>Handler: Send request_started signal\n    Handler->>Flask: Execute code\n    Note over Flask,Handler: Request processed\n```\nThis diagram shows how Flask sends a signal to a handler, which then executes code in response.\n\n## References\n* `[tests/test_signals.py](tests/test_signals.py)`\n* `[src/flask/app.py](src/flask/app.py)`\n* `[src/flask/signals.py](src/flask/signals.py)`\n* `[docs/signals.rst](docs/signals.rst)`"
  },
  "page-6": {
    "title": "Example Applications",
    "section": "Examples and Notebooks",
    "markdown": "# Example Applications\n## Overview\nThis section provides examples of Flask applications, including a simple \"Hello, World!\" app and a more complex blog app, which can be found in the `examples/tutorial` directory.\n\n## Key Components / Concepts\nThe key components of a Flask application include the Flask instance, routes, and templates. The Flask instance is created by calling the `Flask` class and passing the name of the module or package, as seen in `src/flask/app.py`. Routes are used to map URLs to specific functions, and templates are used to render HTML pages.\n\n## How it Works\nTo create a Flask application, you first need to import the Flask class and create an instance of it. Then, you can define routes using the `@app.route` decorator. For example:\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/hello\")\ndef hello():\n    return \"Hello, World!\"\n```\nThis code is similar to what can be found in `examples/tutorial/flaskr/__init__.py`.\n\n## Example(s)\nHere is an example of a simple \"Hello, World!\" app:\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/hello\")\ndef hello():\n    return \"Hello, World!\"\n\nif __name__ == \"__main__\":\n    app.run()\n```\nAnd here is an example of a more complex blog app:\n```python\nfrom flask import Flask, render_template\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n@app.route(\"/posts\")\ndef posts():\n    return render_template(\"posts.html\")\n\nif __name__ == \"__main__\":\n    app.run()\n```\n## Diagram(s)\n```mermaid\nflowchart\n    A[Create Flask instance] --> B[Define routes]\n    B --> C[Run application]\n    C --> D[Render templates]\n```\nThis flowchart shows the basic steps involved in creating a Flask application, which is also tested in `tests/test_cli.py`.\n\n## References\n* `examples/tutorial/flaskr/__init__.py`\n* `src/flask/app.py`\n* `tests/test_cli.py`"
  },
  "page-11": {
    "title": "Tutorial Example",
    "section": "Examples and Notebooks",
    "markdown": "# Tutorial Example\n## Overview\nThe tutorial example provided in the repository is a basic Flask application that demonstrates how to create a simple blog with user authentication, utilizing files such as `examples/tutorial/flaskr/__init__.py` for initialization and `examples/tutorial/flaskr/db.py` for database interactions.\n\n## Key Components / Concepts\nThe key components of the tutorial example include:\n* User authentication using a login and registration system, as seen in `examples/tutorial/flaskr/auth.py`\n* A blog with the ability to create, read, update, and delete posts, which is tested in `examples/tutorial/tests/test_blog.py`\n* A database to store user and post data, managed by `examples/tutorial/flaskr/db.py`\n\n## How it Works\nThe tutorial example works by using Flask to create a web application that interacts with a database to store and retrieve data. The application uses a login and registration system to authenticate users, and allows users to create, read, update, and delete posts, with the database serving as the central storage for all data.\n\n## Example(s)\nAn example of how the tutorial example works can be seen in the `test_index` function in `examples/tutorial/tests/test_blog.py`, which tests the index page of the blog, ensuring that posts are correctly retrieved from the database and displayed to the user.\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant User as \"User\"\n    participant App as \"Flask App\"\n    participant DB as \"Database\"\n\n    User->>App: Request index page\n    App->>DB: Retrieve posts\n    DB->>App: Return posts\n    App->>User: Display index page with posts\n```\nThis flowchart shows the interaction between the user, the Flask application, and the database when the user requests the index page of the blog, highlighting the key steps involved in displaying the blog posts.\n\n## References\n* `examples/tutorial/flaskr/__init__.py`\n* `examples/tutorial/flaskr/db.py`\n* `examples/tutorial/tests/test_blog.py`"
  },
  "page-12": {
    "title": "Celery Example",
    "section": "Examples and Notebooks",
    "markdown": "# Celery Example\n## Overview\nThe Celery example provided in the repository demonstrates how to integrate Celery with a Flask application. Celery is a distributed task queue that allows you to run tasks asynchronously in the background.\n\n## Key Components / Concepts\nThe key components of the Celery example include:\n* The `create_app` function, which creates a Flask application and configures it to use Celery.\n* The `celery_init_app` function, which initializes the Celery application and configures it to use the Flask application's configuration.\n* The `add` function, which is a task that can be run asynchronously using Celery.\n\n## How it Works\nThe Celery example works by creating a Flask application and configuring it to use Celery. The `create_app` function creates a Flask application and configures it to use Celery by calling the `celery_init_app` function. The `celery_init_app` function initializes the Celery application and configures it to use the Flask application's configuration.\n\n## Example(s)\nAn example of how to use the Celery example is to run the `add` task asynchronously using Celery. This can be done by calling the `add` function and passing in the required arguments.\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant Flask as \"Flask Application\"\n    participant Celery as \"Celery Application\"\n    participant Task as \"Task\"\n\n    Flask->>Celery: Create Celery application\n    Celery->>Task: Run task asynchronously\n    Task->>Celery: Return result\n    Celery->>Flask: Return result to Flask application\n```\nCaption: Flowchart showing how the Celery example works.\n\n## References\n* `examples/celery/src/task_app/__init__.py`\n* `examples/celery/src/task_app/tasks.py`\n* `examples/celery/make_celery.py`"
  },
  "page-13": {
    "title": "JavaScript Example",
    "section": "Examples and Notebooks",
    "markdown": "# JavaScript Example\n## Overview\nThe JavaScript example provided in the repository is a basic demonstration of how to integrate JavaScript with a Flask application. It includes a simple view function and test cases to ensure the functionality works as expected.\n\n## Key Components / Concepts\nThe key components of this example include:\n- A view function `index` in `examples/javascript/js_example/views.py` that renders an HTML template based on the provided JavaScript file name.\n- Test cases in `examples/javascript/tests/test_js_example.py` to verify the correctness of the view function and the rendered template.\n\n## How it Works\nThe `index` function in `examples/javascript/js_example/views.py` takes a JavaScript file name as input and renders the corresponding HTML template. The test cases in `examples/javascript/tests/test_js_example.py` simulate requests to the view function and assert that the rendered template is correct.\n\n## Example(s)\nFor example, the `test_index` function in `examples/javascript/tests/test_js_example.py` tests the `index` view function by sending a GET request to the specified path and verifying that the rendered template matches the expected template name.\n\n## Diagram(s)\n```mermaid\nflowchart\n    A[Client Request] -->|GET /path|> B[View Function]\n    B -->|Render Template|> C[HTML Template]\n    C -->|Return Response|> A\n```\nThis flowchart illustrates the basic flow of the JavaScript example, from the client request to the view function and finally to the rendered HTML template.\n\n## References\n- `examples/javascript/js_example/views.py`\n- `examples/javascript/tests/test_js_example.py`\n- `examples/javascript/tests/conftest.py`"
  },
  "page-21": {
    "title": "Flask Tutorial",
    "section": "Examples and Notebooks",
    "markdown": "# Flask Tutorial\n## Overview\nThe Flask tutorial is a step-by-step guide on building a Flask application, covering key components and concepts such as creating and configuring an instance of the Flask application, found in `examples/tutorial/flaskr/__init__.py`.\n\n## Key Components / Concepts\nThe key components of Flask include the application instance, routes, templates, and databases. The application instance is created using the `Flask` class from `src/flask/app.py`, and routes are defined using the `@app.route` decorator. Templates are rendered using the `render_template` function, and databases are integrated using the `db` object from `examples/tutorial/flaskr/db.py`.\n\n## How it Works\nThe Flask application works by creating an instance of the `Flask` class and defining routes using the `@app.route` decorator. The application instance is configured using the `app.config` object, and databases are integrated using the `db` object. This process is outlined in the tutorial documentation at `docs/tutorial/index.rst`.\n\n## Example(s)\nAn example of a simple Flask application is shown in the `examples/tutorial/flaskr/__init__.py` file. This file defines a Flask application instance and a route for the `/hello` URL. The database configuration is defined in `examples/tutorial/flaskr/db.py`, demonstrating how to integrate a database into a Flask application.\n\n## Diagram(s)\n```mermaid\nflowchart\n    A[Create Flask App] --> B[Define Routes]\n    B --> C[Configure App]\n    C --> D[Run App]\n    D --> E[Render Templates]\n    E --> F[Integrate Database]\n```\nThis flowchart shows the basic steps involved in creating a Flask application, including rendering templates and integrating a database.\n\n## References\n* `examples/tutorial/flaskr/__init__.py`\n* `examples/tutorial/flaskr/db.py`\n* `src/flask/app.py`\n* `docs/tutorial/index.rst`"
  },
  "page-27": {
    "title": "Example Application",
    "section": "Examples and Notebooks",
    "markdown": "# Example Application\n## Overview\nThe example application is a basic Flask application that demonstrates how to create and configure an instance of the Flask application.\n\n## Key Components / Concepts\nThe key components of the example application include:\n- Creating and configuring a Flask application instance\n- Defining routes for the application\n- Registering database functions with the application\n- Running the application on a local development server\n\n## How it Works\nThe example application works by creating a Flask application instance and configuring it with the necessary settings and routes. The application then registers database functions and runs on a local development server.\n\n## Example(s)\nAn example of creating a Flask application instance can be seen in the `examples/tutorial/flaskr/__init__.py` file.\n\n## Diagram(s)\n```mermaid\nflowchart\n    A[Create Flask App] --> B[Configure App]\n    B --> C[Define Routes]\n    C --> D[Register Database Functions]\n    D --> E[Run App on Local Server]\n```\nThis flowchart shows the basic steps involved in creating and running a Flask application.\n\n## References\n- `examples/tutorial/flaskr/__init__.py`\n- `src/flask/app.py`\n- `src/flask/config.py`"
  },
  "page-8": {
    "title": "Session Management",
    "section": "Data Management/Flow",
    "markdown": "# Session Management\n## Overview\nSession management in Flask is a crucial aspect of handling user data across multiple requests. It allows the application to store and retrieve information about the user, enabling features like user authentication and personalized experiences.\n\n## Key Components / Concepts\nThe key components involved in session management are:\n- `SessionInterface`: The basic interface for replacing the default session interface, located in [src/flask/sessions.py](src/flask/sessions.py).\n- `SessionMixin`: Expands a basic dictionary with session attributes.\n- `make_null_session`: Creates a null session that acts as a replacement if the real session support cannot be loaded.\n\n## How it Works\nFlask uses a secure cookie to store the session data on the client-side. When a request is made, the session data is retrieved from the cookie and made available to the application. The application can then modify the session data, which is updated in the cookie.\n\n## Example(s)\nTo use sessions in a Flask application, you need to set the `secret_key` configuration. Here's an example:\n```python\nfrom flask import Flask, session\n\napp = Flask(__name__)\napp.secret_key = 'your_secret_key'\n\n@app.route('/')\ndef index():\n    session['key'] = 'value'\n    return 'Session set'\n```\nThis example is based on the test case in [tests/test_basic.py](tests/test_basic.py).\n\n## Diagram(s)\n```mermaid\nflowchart\n    participant Client as \"Client\"\n    participant Server as \"Server\"\n    participant Session as \"Session\"\n\n    Client->>Server: Request\n    Server->>Session: Get session data\n    Session->>Server: Return session data\n    Server->>Client: Response with session cookie\n    Client->>Server: Request with session cookie\n    Server->>Session: Update session data\n    Session->>Server: Return updated session data\n    Server->>Client: Response with updated session cookie\n```\nCaption: Session management flowchart\n\n## References\n- `[src/flask/sessions.py](src/flask/sessions.py)`\n- `[tests/test_basic.py](tests/test_basic.py)`\n- `[docs/api.rst](docs/api.rst)`"
  }
}